<!doctype html><html><head><meta charset=utf-8><meta name=description content="Aloha! Welcome to cheon's blog."><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=apple-touch-icon sizes=76x76 href=https://number317.github.io/blog/img/apple-touch-icon.png><link rel=icon href=https://number317.github.io/blog/img/pen.svg><link rel=stylesheet href=https://number317.github.io/blog/css/global.css><link rel=stylesheet href=https://number317.github.io/blog/css/nav.css><link rel=stylesheet href=https://number317.github.io/blog/css/header.css><link rel=stylesheet href=https://number317.github.io/blog/css/index.css><link rel=stylesheet href=https://number317.github.io/blog/css/list.css><link rel=stylesheet href=https://number317.github.io/blog/css/single.css><link rel=stylesheet href=https://number317.github.io/blog/css/footer.css><link href="https://fonts.googleapis.com/css?family=Fira+Mono|Noto+Sans+SC|Old+Standard+TT&display=swap" rel=stylesheet><link href=https://netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css rel=stylesheet><script src=https://number317.github.io/blog/js/single.js></script><title>cheon's blog</title></head><body><section id=header><ul id=menus><li class=menu><a href=https://number317.github.io><span>Home</span></a></li><li class=menu><a href=https://number317.github.io/blog/categories><span>Categories</span></a></li><li class=menu><a href=https://number317.github.io/blog/tags><span>Tags</span></a></li><li class=menu><a href=https://github.com/number317><span>Projects</span></a></li></ul><h1 id=title><a href=https://number317.github.io/blog/>cheon's blog</a></h1></section><ul id=nav><li>»
<a href=https://number317.github.io/blog/>cheon's blog</a></li><li>»
<a href=https://number317.github.io/blog/c/>c</a></li><li class=active>»
<a href=https://number317.github.io/blog/c/gnu_argp/>GNU Argp</a></li></ul><div id=content><main id=main><h1>GNU Argp</h1><time>Last updated Tue Dec 17, 2024</time><div><aside><h2>Table of Content</h1><nav id=TableOfContents><ul><li><a href=#前置知识>前置知识</a><ul><li><a href=#从一个示例开始>从一个示例开始</a></li><li><a href=#命令行参数>命令行参数</a></li><li><a href=#选项的参数>选项的参数</a></li></ul></li><li><a href=#step0-第一个-argp-程序>step0: 第一个 argp 程序</a></li><li><a href=#step1-短选项>step1: 短选项</a></li><li><a href=#step2-选项参数>step2: 选项参数</a></li><li><a href=#step3-长选项>step3: 长选项</a></li><li><a href=#step4-可选项>step4: 可选项</a></li><li><a href=#step5-别名>step5: 别名</a></li><li><a href=#step6-回调自身>step6: 回调自身</a></li><li><a href=#step7-参数支持>step7: 参数支持</a></li><li><a href=#step8-隐藏选项>step8: 隐藏选项</a></li><li><a href=#step9-完善说明>step9: 完善说明</a></li><li><a href=#step10-选项组>step10: 选项组</a></li><li><a href=#step11-调用库>step11: 调用库</a></li></ul></nav></aside><article id=content><h1 id=gnu-argp-库>GNU Argp 库</h1><p>c 命令行程序中的参数处理是很常见的需求，要做到这点我们可以用 GNU 的标准库 argp，大部分 GNU 组件都用这个库来解析参数。</p><h2 id=前置知识>前置知识</h2><h3 id=从一个示例开始>从一个示例开始</h3><p>先来看一个例子:</p><details><summary><code>sum --help</code></summary><pre><code>sum --help
Usage: sum [OPTION]... [FILE]...
Print checksum and block counts for each FILE.

With no FILE, or when FILE is -, read standard input.

  -r              use BSD sum algorithm, use 1K blocks
  -s, --sysv      use System V sum algorithm, use 512 bytes blocks
      --help     display this help and exit
      --version  output version information and exit

GNU coreutils online help: &lt;https://www.gnu.org/software/coreutils/&gt;
Full documentation &lt;https://www.gnu.org/software/coreutils/sum&gt;
or available locally via: info '(coreutils) sum invocation'
</code></pre></details><p>这是一个调用 <code>--help</code> 选项常见的输出。受到 BNF 影响， <code>[]</code> 意味着是可选的项， <code>...</code> 意味着是可重复的项。因此上面的输出意味着 <code>sum</code> 命令可以有 0 个或多个选项，可以有 0 个或多个文件。</p><h3 id=命令行参数>命令行参数</h3><p>大多数命令行程序可以有参数(arguments)和选项(options)。参数可以是文件名，就像在 <code>cp</code> 命令中看到的:</p><pre><code>cp -v foo bar
</code></pre><p>有些时候，一个参数看起来很像一个选项。例如，你可能有一个目录，名为 <code>--foo</code> ，现在你想要删除它。运行 <code>rmdir --foo</code> 将会导致 <code>rmdir</code> 程序报告没有 <code>--foo</code> 选项的错误。因为这个参数是无法和长选项区分的，我们需要为程序提供一个指示说明我们提供的是参数而不是选项。要做到这点，我们可以使用 <code>--</code> 来告诉程序不再有更多的参数提供给程序:</p><pre><code>mkdir --foo
mkdir: unrecognized option '--foo'
Try 'mkdir --help' for more information.

mkdir -- --foo

rmdir --foo
rmdir: unrecognized option '--foo'
Try 'rmdir --help' for more information.

rmdir -- --foo
</code></pre><p><code>--</code> 的使用在 argp 库中是默认的处理行为。</p><h3 id=选项的参数>选项的参数</h3><p>和程序一样，选项（通常是长选项）也可以有参数。参数可以是强制参数，可选参数，或者没有参数:</p><details><summary><code>fold --help</code></summary><pre><code>fold --help
Usage: fold [OPTION]... [FILE]...
Wrap input lines in each FILE, writing to standard output.

With no FILE, or when FILE is -, read standard input.

Mandatory arguments to long options are mandatory for short options too.
  -b, --bytes         count bytes rather than columns
  -s, --spaces        break at spaces
  -w, --width=WIDTH   use WIDTH columns instead of 80
      --help     display this help and exit
      --version  output version information and exit

GNU coreutils online help: &lt;https://www.gnu.org/software/coreutils/&gt;
Full documentation &lt;https://www.gnu.org/software/coreutils/fold&gt;
or available locally via: info '(coreutils) fold invocation'
</code></pre></details><p>可以看到 <code>--width</code> 选项需要一个数字作为参数。使用 <code>--width</code> 选项而不提供参数是错误的，可以有多种方式为 <code>--width</code> 选项提供参数:</p><details><summary><code>folder</code></summary><pre><code>echo &quot;hello there&quot; | fold -w3
hel
lo 
the
re

echo &quot;hello there&quot; | fold -w 4
hell
o th
ere

echo &quot;hello there&quot; | fold --width 5
hello
 ther
e

echo &quot;hello there&quot; | fold --width=6
hello 
there
</code></pre></details><p>带参数的短选项是值得注意的，这不怎么常见，一个例子是 GNU Make 的 <code>-j</code> 参数:</p><pre><code>-j [N], --jobs[=N]          Allow N jobs at once; infinite jobs with no arg.
-k, --keep-going            Keep going when some targets can't be made.
</code></pre><p>需要值得注意的地方是这种类型的选项可以和 <code>-k</code> 一起使用，但不能是 <code>-k</code> 在 <code>-j</code> 之后。即 make -kj 可以正常工作，但 make -jk 不能。因为这里的 k 被认为是 -j 的参数，而 k 作为 j 的参数是不合法的，它明显不是个数字。</p><h2 id=step0-第一个-argp-程序>step0: 第一个 argp 程序</h2><p>step0.c:</p><pre><code>#include &lt;argp.h&gt;

int main(int argc, char **argv) {
  return argp_parse(0, argc, argv, 0, 0, 0);
}
</code></pre><details><summary>编译运行</summary><pre><code>make step0

./step0 --help
Usage: step0 [OPTION...]

  -?, --help                 Give this help list
      --usage                Give a short usage message

./step0 --usage
Usage: step0 [-?] [--help] [--usage]

./step0 foo
step0: Too many arguments
Try `step0 --help' or `step0 --usage' for more information.

./step0 --us
Usage: step0 [-?] [--help] [--usage]

./step0 --foo
./step0: unrecognized option '--foo'
Try `step0 --help' or `step0 --usage' for more information.

./step0 --usage --help
Usage: step0 [-?] [--help] [--usage]
</code></pre></details><p>通过测试证明以下几件事:</p><ol><li>argp 自动做了一些错误处理，默认不允许任何参数</li><li>我们可以使用 <code>-us</code> 代替 <code>--usage</code> 并且效果相同</li><li>对于系统不识别的选项做了错误处理</li><li>用 <code>--</code> 说明命令行的选项结束</li></ol><h2 id=step1-短选项>step1: 短选项</h2><p>为之前的程序添加一个 <code>-d</code> 选项，是程序在屏幕上打印一个 <code>.</code> :</p><detail><summary><code>step1.c</code></summary><pre><code>#include &lt;argp.h&gt;
#include &lt;stdio.h&gt;

static int parse_opt(int key, char *arg, struct argp_state *state) {
  switch(key) {
  case 'd':
    printf(&quot;.\n&quot;);
    break;
  }
  return 0;
}

int main(int argc, char **argv) {
  struct argp_option options[] =
    {
     { 0, 'd', 0, 0, &quot;show a dot on the screen&quot;},
     { 0 }
    };
  struct argp argp = { options, parse_opt };
  return argp_parse(&amp;argp, argc, argv, 0, 0, 0);
}
</code></pre></details><p><code>argp_option</code> 结构体有 5 个字段，为 0 的表示没有用到，第二个字段 <code>-d</code> 表示短选项，第五个字段包含在 <code>--help</code> 选项中显示的描述。
在 argp 中最重要的数据类型是 <code>struct argp</code> 。这里可以看到它包含:</p><ol><li>所有的选项（现在只有一个）</li><li>一个指向 argp 用于解析选项的函数的指针（ <code>parse_opt</code> ）</li></ol><p>注意到 <code>parse_opt</code> 是一个回调函数，在代码中没有被显示地调用，而是被传递给了 <code>struct argp</code> 作为参数，这里实际是把指向函数所在地址的指针传递给了 <code>struct argp</code> ，这与数组名指向数组的第一个元素类似，如果查看 argp 的源码可以看到 <code>parse_opt</code> 被重复地调用来处理每一个选项和参数。</p><details><summary>编译运行</summary><pre><code>make step1

./step1 --help
Usage: step1 [OPTION...]

  -d                         show a dot on the screen
  -?, --help                 Give this help list
      --usage                Give a short usage message

./step1 -d
.

./step1 -ddd -d
.
.
.
.
</code></pre></details><h2 id=step2-选项参数>step2: 选项参数</h2><p>现在为 <code>-d</code> 选项添加一个参数，好让程序输出更多的 <code>.</code> 而不是一个。</p><details><summary><code>step2.c</code></summary><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;argp.h&gt;
static int parse_opt(int key, char *arg, struct argp_state *state) {
    switch(key) {
        case 'd': {
            unsigned int i;
            for(i=0; i&lt;atoi(arg); i++)
                printf(&quot;.&quot;);
            printf(&quot;\n&quot;);
            break;
        }
    }
    return 0;
}

int main(int argc, char **argv) {
    struct argp_option options[] = {
        { 0, 'd', &quot;NUM&quot;, 0, &quot;Show some dots on the screen&quot;},
        { 0 }
    };

    struct argp argp = { options. parse_opt, 0, 0 };
    return argp_parse(&amp;argp, argc, argv, 0, 0, 0);
}
</code></pre></details><p>现在用到了 <code>argp_option</code> 的第三个字段，这表明 <code>-d</code> 选项有一个名为 <code>NUM</code> 的参数，这会在 <code>--help</code> 和 <code>--usage</code> 中显示。如果把这个字段改回 <code>0</code> 或 <code>NULL</code> ， <code>-d</code> 选项会停止接受强制参数。</p><p>在 <code>parse_opt</code> 回调函数中，使用了 <code>arg</code> 参数。它是字符串类型，不能为 <code>NULL</code> 因为 argp 不允许没有参数调用 <code>-d</code> 。 <code>arg</code> 指向没有申请过的内存，尝试去强制释放它不是一个好主意。</p><details><summary>编译运行</summary><pre><code>make step2

./step2 --help
Usage: step2 [OPTION...]

  -d NUM                     Show some dots on the screen
  -?, --help                 Give this help list
      --usage                Give a short usage message

./step2 -d1 -d2 -d 3
.
..
...

./step2 -d
./step2: option requires an argument -- 'd'
Try `step2 --help' or `step2 --usage' for more information.

./step2 --usage
Usage: step2 [-?] [-d NUM] [--help] [--usage]
</code></pre></details><h2 id=step3-长选项>step3: 长选项</h2><p>现在为 <code>-d</code> 选项添加一个等价的长选项 <code>--dot</code> 。</p><details><summary><code>step3.c</code></summary><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;argp.h&gt;
static int parse_opt(int key, char *arg, struct argp_state *state) {
    switch(key) {
        case 'd': {
            unsigned int i;
            for(i=0; i&lt;atoi(arg); i++)
                printf(&quot;.&quot;);
            printf(&quot;\n&quot;);
            break;
        }
    }
    return 0;
}

int main(int argc, char **argv) {
    struct argp_option options[] = {
        { &quot;dot&quot;, 'd', &quot;NUM&quot;, 0, &quot;Show some dots on the screen&quot;},
        { 0 }
    };
    struct argp argp = { options, parse_opt, 0, 0 };
    return argp_parse(&amp;argp, argc, argv, 0, 0, 0);
}
</code></pre></details><p><code>struct argp_option</code> 的第一个字段控制长选项的名字。如果在选项名字中有空格，新行，tab 或不可打印的字符，会报错。</p><details><summary>编译运行</summary><pre><code>make step3

./step3 --help
Usage: step3 [OPTION...]

  -d, --dot=NUM              Show some dots on the screen
  -?, --help                 Give this help list
      --usage                Give a short usage message

Mandatory or optional arguments to long options are also mandatory or optional
for any corresponding short options.

./step3 --dot 1 --dot=2 -d3
.
..
...

./step3 --dot
./step3: option '--dot' requires an argument
Try `step3 --help' or `step3 --usage' for more information.

./step3 --do 12
............

./step3 --usage
Usage: step3 [-?] [-d NUM] [--dot=NUM] [--help] [--usage]
</code></pre></details><p>现在可以看到 <code>--help</code> 信息中有了 <code>--dot</code> 选项。在 help 信息底部有一个唠叨的信息，告诉你 <code>NUM</code> 也是短选项 <code>-d</code> 的参数。可以设置环境变量 <code>ARGP_HELP_FMT</code> 的值为 <code>no-dup-args-note</code> 来关闭这个信息。</p><pre><code>export ARGP_HELP_FMT=&quot;no-dup-args-note&quot;

./step3 --help
Usage: step3 [OPTION...]

  -d, --dot=NUM              Show some dots on the screen
  -?, --help                 Give this help list
      --usage                Give a short usage message
</code></pre><h2 id=step4-可选项>step4: 可选项</h2><p>现在将 <code>--dot</code> 的 <code>NUM</code> 参数设置为可选的。</p><details><summary><code>step4.c</code></summary><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;argp.h&gt;
static int parse_opt(int key, char *arg, struct argp_state *state) {
    switch(key) {
        case 'd': {
            unsigned int i;
            unsigned int dots = 0;
            if(arg == NULL)
                dots = 1;
            else
                dots = atoi(arg);
            for(i=0; i&lt;dots; i++)
                printf(&quot;.&quot;);
            printf(&quot;\n&quot;);
            break;
        }
    }
    return 0;
}

int main(int argc, char **argv) {
    struct argp_option options[] = {
        { &quot;dot&quot;, 'd', &quot;NUM&quot;, OPTION_ARG_OPTIONAL, &quot;Show some dots on the screen&quot;},
        { 0 }
    };
    struct argp argp = { options, parse_opt, 0, 0 };
    return argp_parse(&amp;argp, argc, argv, 0, 0, 0);
}
</code></pre></details><p><code>struct argp_option</code> 的第四个字段设置选项如何工作。</p><details><summary>编译运行</summary><pre><code>make step4

./step4 --help
Usage: step4 [OPTION...]

  -d, --dot[=NUM]            Show some dots on the screen
  -?, --help                 Give this help list
      --usage                Give a short usage message

./step4 --usage
Usage: step4 [-?] [-d[NUM]] [--dot[=NUM]] [--help] [--usage]

./step4 -d --dot=3 --dot
.
...
.

./step4 --dot 3
.

./step4 -dd
</code></pre></details><p>最后两个例子可能不符合预期，这是因为长选项配合可选参数需要一个 <code>=</code> 放在选项和参数之间，如果没有，参数会被认为是程序的参数，而不是选项的参数。带有可选参数的短选项不能连起来用。第二个 <code>d</code> 被认为是第一个 <code>d</code> 的参数， <code>atoi</code> 将 <code>-d</code> 转换为 <code>0</code> 。</p><h2 id=step5-别名>step5: 别名</h2><details><summary><code>step5.c</code></summary><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;argp.h&gt;

static int parse_opt(int key, char *arg, struct argp_state *state) {
    switch(key) {
        case 'd': {
            unsigned int i;
            unsigned int dots = 0;
            if(arg == NULL)
                dots = 1;
            else
                dots = atoi(arg);
            for(i = 0; i &lt; dots; i++)
                printf(&quot;.&quot;);
            printf(&quot;\n&quot;);
            break;
        }
    }
    return 0;
}

int main(int argc, char **argv) {
    struct argp_option options[] =
        {
         { &quot;dot&quot;, 'd', &quot;NUM&quot;, OPTION_ARG_OPTIONAL, &quot;Show some dots on the screen&quot; },
         { &quot;period&quot;, 0, &quot;FOO&quot;, OPTION_ALIAS, &quot;Bar&quot; },
         { 0 }
        };
    struct argp argp = { options, parse_opt, 0, 0};
    return  argp_parse(&amp;argp, argc, argv, 0, 0, 0);
}
</code></pre></details><p><code>OPTION_ALIAS</code> 使得选项继承前一个选项的所有字段，除了第一字段长选项名和第二字段短选项名。可以有任意多个别名。一些字段被随意填充了值来阐明它们其实被 argp 忽略了。</p><details><summary>编译运行</summary><code>make step5<p>./step5 &ndash;help
Usage: step5 [OPTION&mldr;]</p><p>-d, &ndash;dot[=NUM], &ndash;period[=NUM]
Show some dots on the screen
-?, &ndash;help Give this help list
&ndash;usage Give a short usage message</p><p>./step5 &ndash;usage
Usage: step5 [-?] [-d[NUM]] [&ndash;dot[=NUM]] [&ndash;period[=FOO]] [&ndash;help] [&ndash;usage]</p><p>./step5 &ndash;period
.</p><p>./step5 &ndash;period=4
&mldr;.</code></p></details><p>可以看到 <code>FOO</code> 和 <code>Bar</code> 被正确地忽略了，没有在 help 信息中显示出来。新的长选项 <code>--period</code> 出现在 <code>--dot=</code> 选项旁因为它们是完全等价的。</p><h2 id=step6-回调自身>step6: 回调自身</h2><p>现在为程序添加一个长选项 <code>--ellipsis</code> 用于在屏幕输出 3 个点。功能上等价于 <code>--dot=3</code> :</p><details><summary><code>step6.c</code></summary><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;argp.h&gt;

static int parse_opt(int key, char *arg, struct argp_state *state) {
    switch(key) {
        case 'd': {
            unsigned int i;
            unsigned int dots = 0;
            if(arg == NULL)
                dots = 1;
            else
                dots = atoi(arg);
            for(i = 0; i &lt; dots; i++)
                printf(&quot;.&quot;);
            printf(&quot;\n&quot;);
            break;
        }
        case 777:
            return parse_opt('d', &quot;3&quot;, state);
    }
    return 0;
}

int main(int argc, char **argv) {
    struct argp_option options[] =
        {
         { &quot;dot&quot;, 'd', &quot;NUM&quot;, 0, &quot;Show some dots on the screen&quot; },
         { &quot;ellipsis&quot;, 777, 0, 0, &quot;Show an ellipsis on the screen&quot; },
         { 0 }
        };
    struct argp argp = { options, parse_opt, 0, 0};
    return  argp_parse(&amp;argp, argc, argv, 0, 0, 0);
}
</code></pre></details><p>可以看到 <code>--ellipsis</code> 选项不接收任何参数，并且有一个奇怪的短选项 <code>777</code> 。这是因为 argp 自动检测短选项是否是可打印的字符，由于 <code>777</code> 不是一个可打印的字符，意味着 <code>--ellipsis</code> 没有对应等价的短选项。</p><details><summary>编译运行</summary>make step6<pre><code>./step6 --help
Usage: step6 [OPTION...]

  -d, --dot=NUM              Show some dots on the screen
      --ellipsis             Show an ellipsis on the screen
  -?, --help                 Give this help list
      --usage                Give a short usage message

./step6 --usage
Usage: step6 [-?] [-d NUM] [--dot=NUM] [--ellipsis] [--help] [--usage]

./step6 --ellipsis
...

./step6 --dot 3
...
</code></pre></details><p>由于 <code>--ellipsis</code> 没有参数，所以无法为它创建一个别名。</p><h2 id=step7-参数支持>step7: 参数支持</h2><p>现在为程序添加对一到四个参数的支持。如果程序没有获得足够的参数，将会报错。</p><details><summary><code>step7.c</code></summary><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;argp.h&gt;
static int parse_opt(int key, char *arg, struct argp_state *state) {
    int *arg_count = state-&gt;input;
    switch(key) {
        case 'd': {
            unsigned int i;
            unsigned int dots = 0;
            if(arg == NULL)
                dots = 1;
            else
                dots = atoi(arg);
            for(i = 0; i &lt; dots; i++)
                printf(&quot;.&quot;);
            printf(&quot;\n&quot;);
            break;
        }
        case 777:
            return parse_opt('d', &quot;3&quot;, state);
        case ARGP_KEY_ARG:
            {
                (*arg_count)--;
                if(*arg_count &gt;= 0)
                    printf(&quot; %s&quot;, arg);
            }
            break;
        case ARGP_KEY_END:
            {
                printf(&quot;\n&quot;);
                if(*arg_count &gt;=4)
                    argp_failure(state, 1, 0, &quot;too few arguments&quot;);
                else if(*arg_count &lt; 0)
                    argp_failure(state, 1, 0, &quot;too many arguments&quot;);
            }
            break;
    }
    return 0;
}

int main(int argc, char **argv) {
    struct argp_option options[] =
        {
         { &quot;dot&quot;, 'd', &quot;NUM&quot;, 0, &quot;Show some dots on the screen&quot; },
         { &quot;ellipsis&quot;, 777, 0, 0, &quot;Show an ellipsis on the screen&quot; },
         { 0 }
        };
    int arg_count = 4;
    struct argp argp = { options, parse_opt, &quot;WORD [WORD [WORD [WORD]]]&quot;};
    return  argp_parse(&amp;argp, argc, argv, 0, 0, &amp;arg_count);
}
</code></pre></details><p>在 argp 接收到参数时，它传递 <code>ARGP_KEY_ARG</code> ，当 argp 接收到最后一个参数时，它传递 <code>ARGP_KEY_END</code> 到回调函数。</p><p>argp 提供了一个函数 <code>argp_failure</code> 用于参数解析的错误处理，使用这个函数错误信息会有标准的格式。</p><p><code>state</code> 参数展示了 <code>input</code> 字段，它存放传递给程序的参数，使用它有两个目的:</p><ol><li>知道有多少个参数应该春帝给程序</li><li>知道有多少个参数传递给程序</li></ol><p>argp 也追踪目前为止已经处理了多少个参数，这个信息存放在 <code>arg_num</code> 字段中。</p><p>代码中也传递了一个指针给 <code>argp_parse</code> 作为第 6 个参数。这个参数可以让你传递你想要的数据给回调函数，这通常是一个结构体。</p><p><code>struct argp</code> 也拥有比我们想的更多的字段。第三个字段表示在此命令行中期望的参数。在此例中，期望有四个参数，所以这么写。这里将它们称为 <code>WORD</code> ，因为这符合句子的构造。</p><details><summary>编译运行</summary><pre><code>make step7

./step7 --help

Usage: step7 [OPTION...] WORD [WORD [WORD [WORD]]]

  -d, --dot=NUM              Show some dots on the screen
      --ellipsis             Show an ellipsis on the screen
  -?, --help                 Give this help list
      --usage                Give a short usage message

./step7 --usage
Usage: step7 [-?] [-d NUM] [--dot=NUM] [--ellipsis] [--help] [--usage]
            WORD [WORD [WORD [WORD]]]

./step7 once upon a time
 once upon a time

./step7 one tow three four five
 one tow three four
step7: too many arguments
</code></pre></details><p>首先可以看到参数注解被包含在了 help 和 usage 信息中了，并且用户可以给出一到四个单词作为参数，但不能是没有或者大于四个。</p><p>当在命令最后带上 <code>--ellipsis</code> 长参数时， <code>...</code> 会先输出。这是因为 argp 默认行为是先解析选项，再解析参数。如果想要改变，可以向 <code>argp_parse</code> 函数的第四个参数传递 <code>ARGP_IN_ORDER</code> 。</p><h2 id=step8-隐藏选项>step8: 隐藏选项</h2><p>这里要将程序改造成莫尔斯密码的程序，会添加 <code>--dash</code> 选项，改造 <code>--ellipsis</code> 选项。并且选项在 help 和 usage 信息中被隐藏。程序不再接收任何参数。</p><details><summary><code>step8</code></summary><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;argp.h&gt;

static int parse_opt(int key, char *arg, struct argp_state *state) {
    switch(key) {
        case 'd':
            {
                unsigned int i;
                unsigned int dots = 1;
                if(arg != NULL)
                    dots = atoi(arg);
                for(i=0; i&lt;dots; i++)
                    printf(&quot;.&quot;);
                break;
            }
            break;
        case 888:
            printf(&quot;-&quot;);
            break;
        case 777:
            return parse_opt('d', &quot;3&quot;, state);
        case ARGP_KEY_ARG:
            argp_failure(state, 1, 0, &quot;too many arguments&quot;);
            break;
        case ARGP_KEY_END:
            printf(&quot;\n&quot;);
            break;
    }
    return 0;
}

int main(int argc, char **argv) {
    struct argp_option options[] =
        {
         { &quot;dot&quot;, 'd', &quot;NUM&quot;, OPTION_ARG_OPTIONAL, &quot;Show some dots on the screen&quot; },
         { &quot;ellipsis&quot;, 777, 0, OPTION_HIDDEN, &quot;Show an ellipsis on the screen&quot; },
         { &quot;dash&quot;, 888, 0, 0, &quot;Show a dash on the screen&quot; },
         { 0 }
        };
    int arg_count = 4;
    struct argp argp = { options, parse_opt};
    return  argp_parse(&amp;argp, argc, argv, 0, 0, 0);
}
</code></pre></details><p>上述代码中添加了一个长选项 <code>--dash</code> ，给 <code>--dot</code> 选项一个可选的参数，给了 <code>--ellipsis</code> 一个 <code>OPTION_HIDDEN</code> 参数。这可以使改选项继续生效，但不会在 help 和 usage 信息中显示。</p><details><summary>编译运行</summary><pre><code>make step8

./step8 --help
Usage: step8 [OPTION...]

  -d, --dot[=NUM]            Show some dots on the screen
      --dash                 Show a dash on the screen
  -?, --help                 Give this help list
      --usage                Give a short usage message

./step8 --usage
Usage: step8 [-?] [-d[NUM]] [--dot[=NUM]] [--dash] [--help] [--usage]

./step8 --ellipsis
...

./step8 -d -d --dot --dash --dash --dash
...---

./step8 --dash --
-

./step8 --d
./step8: option '--d' is ambiguous; possibilities: '--dot' '--dash'
Try `step8 --help' or `step8 --usage' for more information.

./step8 dot
step8: too many arguments
</code></pre></details><h2 id=step9-完善说明>step9: 完善说明</h2><details><summary><code>step9</code></summary><pre><code>#include &lt;stdio.h&gt;
#include &lt;argp.h&gt;
#include &lt;argz.h&gt;
#include &lt;stdlib.h&gt;

const char *argp_program_bug_address = &quot;someone@example.com&quot;;
const char *argp_program_version = &quot;version 1.0&quot;;

struct arguments {
    char *argz;
    size_t argz_len;
};

static int parse_opt(int key, char *arg, struct argp_state *state)
{
    struct arguments *a = state-&gt;input;
    switch(key) {
    case 'd':
        {
            unsigned int dots = 1;
            if(arg != NULL)
                dots = atoi(arg);
            for(unsigned int i=0; i&lt;dots; i++)
                printf(&quot;.&quot;);
            break;
        }
    case 888:
        printf(&quot;-&quot;);
        break;
    case ARGP_KEY_ARG:
        argz_add(&amp;a-&gt;argz, &amp;a-&gt;argz_len, arg);
        break;
    case ARGP_KEY_INIT:
        a-&gt;argz = 0;
        a-&gt;argz_len = 0;
        break;
    case ARGP_KEY_END:
        {
            size_t count = argz_count(a-&gt;argz, a-&gt;argz_len);
            if(count&gt;2)
                argp_failure(state, 1, 0, &quot;too many arguments&quot;);
            else if(count&lt;1)
                argp_failure(state, 1, 0, &quot;too few arguments&quot;);
        }
        break;
    }
    return 0;
}

int main(int argc, char **argv) {
    struct argp_option options[] =
        {
         {&quot;dot&quot;, 'd', &quot;NUM&quot;, OPTION_ARG_OPTIONAL, &quot;Show some dots on the screen&quot;},
         {&quot;dash&quot;, 888, 0, 0, &quot;Show a dash on the screen&quot;},
         { 0 }
        };
    struct argp argp = {options, parse_opt, &quot;WORD\nWORD WORD&quot;,
    &quot;Show some dots and dashes on the screen.\v&quot;
    &quot;A final newline is also shown regardless of whether any options were given.&quot;};
    struct arguments arguments;
    if(argp_parse(&amp;argp, argc, argv, 0, 0, &amp;arguments) == 0) {
        const char *prev = NULL;
        char *word;
        while((word = argz_next(arguments.argz, arguments.argz_len, prev))) {
            printf(&quot; %s&quot;, word);
            prev = word;
        }
        printf(&quot;\n&quot;);
        free(arguments.argz);
    }
    return 0;
}
</code></pre></details><p>如果设置了 <code>argp_program_version</code> ，那么长选项 <code>--version</code> 和短选项 <code>-V</code> 会被包含在程序中。如果设置了 <code>argp_program_bug_address</code> ，help 信息将会添加 <code>Repoprt bugs to: foo@bar..</code> 的信息。对于程序而言，这是一种良好的风格，告诉用户应用版本，以及如何报告 bug。</p><p>在上述代码里也用到了 <code>argz</code> 。这是另一个起源与 GNU C 标准库的设施，使用这个库函数来累计程序遇见的参数。结构体 <code>arguments</code> 用于存放参数，它将保留参数，并将其设置为 <code>argp_parse</code> 函数的输入数据挂钩。 <code>stdlib.h</code> 头文件也被引入是因为 argz 向量被分配了内存，需要使用 <code>free</code> 来释放内存。</p><p>回调函数中的新元素是 <code>ARGP_KEY_INIT</code> 。它最先被传到回调函数中在任何解析开始之前。这里用于初始化结构体 <code>arguments</code> 。</p><p>一个新的 argp 元素是第四个元素，它有特殊的字符 <code>\v</code> ，是一个竖向的制表符。在这个制表符之前的所有内容会显示在选项之前，剩下的会在选项之后显示。这个变量的目的有两方面:</p><ol><li>给出程序的简短描述</li><li>更详细地描述程序的选项和操作</li></ol><p>另一个新的地方是在 <code>argp</code> 结构体中第三个字段（ <code>args_doc</code> 字段）的换行符。这是告诉用户有其他运行程序的方式的另一种方法。</p><details><summary>编译运行</summary><pre><code>make step9

./step9 --help
Usage: step9 [OPTION...] WORD
  or:  step9 [OPTION...] WORD WORD
Show some dots and dashes on the screen.

  -d, --dot[=NUM]            Show some dots on the screen
      --dash                 Show a dash on the screen
  -?, --help                 Give this help list
      --usage                Give a short usage message
  -V, --version              Print program version

A final newline is also shown regardless of whether any options were given.

Report bugs to someone@example.com.

./step9 --usage
Usage: step9 [-?V] [-d[NUM]] [--dot[=NUM]] [--dash] [--help] [--usage]
            [--version] WORD
  or:  step9 [OPTION...] WORD WORD

./step9 foo bar
 foo bar

./step9 foo bar baz
step9: too many arguments

./step9
step9: too few arguments

./step9 foo --dash -d
-. foo

./step9 --version
version 1.0
</code></pre></details><p>许多命令有许多不同的 usage 行，如 <code>ln</code> 命令有 4 种用法。argp 使处理这种情况变得容易。</p><h2 id=step10-选项组>step10: 选项组</h2><p>将 <code>--dash</code> 和 <code>--dot</code> 选项放到自己的组中可以使帮助信息的可读性更高。</p><details><summary><code>step10</code></summary><pre><code>#include &lt;stdio.h&gt;
#include &lt;argp.h&gt;
#include &lt;argz.h&gt;
#include &lt;stdlib.h&gt;

const char *argp_program_bug_address = &quot;someone@example.com&quot;;
const char *argp_program_version = &quot;version 1.0&quot;;

struct arguments {
    char *argz;
    size_t argz_len;
};

static int parse_opt(int key, char *arg, struct argp_state *state)
{
    struct arguments *a = state-&gt;input;
    switch(key) {
    case 'd':
        {
            unsigned int dots = 1;
            if(arg != NULL)
                dots = atoi(arg);
            for(unsigned int i=0; i&lt;dots; i++)
                printf(&quot;.&quot;);
            break;
        }
    case 888:
        printf(&quot;-&quot;);
        break;
    case 999:
        parse_opt('d', &quot;3&quot;, state);
        printf(&quot; &quot;);
        parse_opt(888, NULL, state);
        parse_opt(888, NULL, state);
        parse_opt(888, NULL, state);
        printf(&quot; &quot;);
        parse_opt('d', &quot;3&quot;, state);
        printf(&quot;\n&quot;);
        exit(0);
        break;
    case ARGP_KEY_ARG:
        argz_add(&amp;a-&gt;argz, &amp;a-&gt;argz_len, arg);
        break;
    case ARGP_KEY_INIT:
        a-&gt;argz = 0;
        a-&gt;argz_len = 0;
        break;
    case ARGP_KEY_END:
        {
            size_t count = argz_count(a-&gt;argz, a-&gt;argz_len);
            if(count&gt;2)
                argp_failure(state, 1, 0, &quot;too many arguments&quot;);
            else if(count&lt;1)
                argp_failure(state, 1, 0, &quot;too few arguments&quot;);
        }
        break;
    }
    return 0;
}

int main(int argc, char **argv) {
    struct argp_option options[] =
        {
         {0, 0, 0, 0, &quot;Morse Code Options:&quot;, 7},
         {&quot;dot&quot;, 'd', &quot;NUM&quot;, OPTION_ARG_OPTIONAL, &quot;Show some dots on the screen&quot;},
         {&quot;dash&quot;, 888, 0, 0, &quot;Show a dash on the screen&quot;},
         {0, 0, 0, 0, &quot;Information Options:&quot;, -1},
         {&quot;SOS&quot;, 999, 0, 0, &quot;Give some help in morse code&quot;},
         { 0 }
        };
    struct argp argp = {options, parse_opt, &quot;WORD\nWORD WORD&quot;,
    &quot;Show some dots and dashes on the screen.\v&quot;
    &quot;A final newline is also shown regardless of whether any options were given.&quot;};
    struct arguments arguments;
    if(argp_parse(&amp;argp, argc, argv, 0, 0, &amp;arguments) == 0) {
        const char *prev = NULL;
        char *word;
        while((word = argz_next(arguments.argz, arguments.argz_len, prev))) {
            printf(&quot; %s&quot;, word);
            prev = word;
        }
        printf(&quot;\n&quot;);
        free(arguments.argz);
    }
    return 0;
}
</code></pre></details><p>结构体 <code>argp_option</code> 四条记录中只有两条记录指定了 <code>group</code> ，分别是 7 和 -1。这两条记录被称为头，通常的惯例是将其文本以冒号结尾。 <code>group</code> 字段被当作在帮助信息中用于排序选项的主键。拥有更大的非负数值的记录会排在更小的非负数值的记录之后。拥有负数值的记录排在非负值记录之后。小的负值记录排在大的负值记录之后。排序方式形如 <code>0 ,1, 2, ..., n, -m, ..., -2, -1</code> 。其他记录没有指定 <code>group</code> 字段。因为这些字段在头记录之后的记录中会自动设置。所以 <code>--dot</code> 和 <code>--dash</code> 自动接收到值 7。通常用法是对没有头的选项不设置该值。</p><p>组值为零且未出现在选项标题之后的选项将保持其零值，并出现在帮助输出中的所有其他选项之前。 如果我们在选项标题中省略了组值，则会自动将其设置为比前一个选项的组值大一个的值。 自动设置组值的目的是在简单的情况下不必提供组值。</p><details><summary>编译运行</summary><pre><code>make step10

./step10 --help
Usage: step10 [OPTION...] WORD
  or:  step10 [OPTION...] WORD WORD
Show some dots and dashes on the screen.

 Morse Code Options:
  -d, --dot[=NUM]            Show some dots on the screen
      --dash                 Show a dash on the screen

 Information Options:
  -?, --help                 Give this help list
      --SOS                  Give some help in morse code
      --usage                Give a short usage message
  -V, --version              Print program version

A final newline is also shown regardless of whether any options were given.

Report bugs to someone@example.com.

./step10 -SOS
... --- ...
</code></pre></details><p>可以看到莫尔斯密码选项都在同一组， <code>--dot</code> 选项出现在 <code>--dash</code> 选项之前，因为排序的第二个键是短选项，第三个键才是长选项。</p><p><code>--SOS</code> 选项也出现在了其他帮助信息中，因为默认选项也有 -1 的组值。</p><h2 id=step11-调用库>step11: 调用库</h2><p>可能有两个程序并且希望他们有相同的选项，argp 让这个实现变得简单，不需要复制代码。对于程序员而言，将程序中的函数压缩成一个库好让别的应用使用 api 来构建新应用。很多情况下 api 有一些配置元素，甚至是配置文件。程序员需要收集这些信息然后传递给 api。</p><details><summary><code>dotdash.c</code></summary><pre><code>#include &quot;dotdash.h&quot;
static int parse_opt(int key, char *arg, struct argp_state *state) {
    switch(key) {
        case 'd':
        {
            unsigned int dots = 1;
            if(arg != NULL)
                dots = atoi(arg);
            for(unsigned int i=0; i&lt;dots; i++)
                printf(&quot;.&quot;);
            break;
        }
        case 888:
            printf(&quot;-&quot;);
            break;
    }
    return 0;
}

static struct argp_option options[] =
{
    {&quot;dot&quot;, 'd', &quot;NUM&quot;, OPTION_ARG_OPTIONAL, &quot;Show some dots on the screen&quot;},
    {&quot;dash&quot;, 888, 0, 0, &quot;Show a dash on the screen&quot;},
    { 0 }
};

struct argp dotdash_argp = {options, parse_opt, 0, 0, 0};
</code></pre></details><p>dotdash.h:</p><pre><code>#ifndef DASHDOT_H
#define DASHDOT_H
#include &lt;argp.h&gt;
extern struct argp dotdash_argp;
#endif
</code></pre><details><summary>`step11.c`</summary><pre><code>#include &lt;stdio.h&gt;
#include &lt;argp.h&gt;
#include &quot;dotdash.h&quot;

static int parse_opt(int key, char *arg, struct argp_state *state) {
    switch(key) {
        case 999:
            printf(&quot;...---...&quot;);
            break;
    }
    return 0;
}

int main(int argc, char **argv) {
    struct argp_option options[] =
    {
        {&quot;SOS&quot;, 999, 0, 0, &quot;Show the SOS sequence on the screen&quot;},
        { 0 }
    };
    struct argp_child children_parsers[] =
    {
        {&amp;dotdash_argp. 0, &quot;Basic Morse Code Options:&quot;, 7},
        {0},
    };
    struct argp argp = {options, parse_opt, 0, 0, children_parsers};
    int retval = argp_parse(&amp;argp, argc, argv, 0, 0, 0);
    printf(&quot;\n&quot;);
    return retval;
}
</code></pre></details><details><summary>编译运行</summary><pre><code>cc -c -o dotdash.o dotdash.c

ar cr libdotdash.a dotdash.o

ranlib libdotdash.a

cc step11.c -L./ -ldotdash -o step11

./step11 --help
Usage: step11 [OPTION...]

      --SOS                  Show the SOS sequence on the screen

 Basic Morse Code Options:
  -d, --dot[=NUM]            Show some dots on the screen
      --dash                 Show a dash on the screen

  -?, --help                 Give this help list
      --usage                Give a short usage message
</code></pre></details></article></div></main><div><h4 id=signature>Thu Nov 28, 2019
cheon</h4><ul class=tags><li><a href=https://number317.github.io/blog/tags/library>library</a></li></ul><ul class=related><li><a class=previous href=https://number317.github.io/blog/c/low_level_io/>Low Level I/O</a></li></ul></div></div><section id=footer><div id=author><h2>About Author</h2><hr><img src=https://number317.github.io/images/author.jpg></img><p>Life is dance we all have to do.</p></div><ul id=link><li><a href=https://github.com/number317/aloha.git target=_blank><i class="fa fa-github" alt=github></i></a></li><li><a href="mailto:cheon0112358d@gmail.com?subject=blog%27s%20feedback" target=_blank><i class="fa fa-envelope" alt=email></i></a></li><li id=wechat><i class="fa fa-wechat"></i></li><img class=qrcode src=https://number317.github.io/images/wechat.jpg></ul></section></body></html>