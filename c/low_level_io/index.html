<!doctype html><html><head><meta charset=utf-8><meta name=description content="Aloha! Welcome to cheon's blog."><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=viewport content="width=device-width,initial-scale=1"><link rel=apple-touch-icon sizes=76x76 href=https://number317.github.io/blog/img/apple-touch-icon.png><link rel=icon href=https://number317.github.io/blog/img/pen.svg><link rel=stylesheet href=https://number317.github.io/blog/css/global.css><link rel=stylesheet href=https://number317.github.io/blog/css/nav.css><link rel=stylesheet href=https://number317.github.io/blog/css/header.css><link rel=stylesheet href=https://number317.github.io/blog/css/index.css><link rel=stylesheet href=https://number317.github.io/blog/css/list.css><link rel=stylesheet href=https://number317.github.io/blog/css/single.css><link rel=stylesheet href=https://number317.github.io/blog/css/footer.css><link href="https://fonts.font.im/css?family=Fira+Mono|Noto+Sans|Old+Standard+TT" rel=preload as=style onload='this.onload=null,this.rel="stylesheet"'><link href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css rel=preload as=style onload='this.onload=null,this.rel="stylesheet"'><script src=https://number317.github.io/blog/js/single.js></script><link href=https://cdnjs.cloudflare.com/ajax/libs/viewerjs/1.11.7/viewer.min.css rel=preload as=style onload='this.onload=null,this.rel="stylesheet"'><script src=https://cdnjs.cloudflare.com/ajax/libs/viewerjs/1.11.7/viewer.min.js async></script><title>cheon's blog</title></head><body><section id=header><ul id=menus><li class=menu><a href=https://number317.github.io><span>Home</span></a></li><li class=menu><a href=https://number317.github.io/blog/categories><span>Categories</span></a></li><li class=menu><a href=https://number317.github.io/blog/tags><span>Tags</span></a></li><li class=menu><a href=https://github.com/number317><span>Projects</span></a></li></ul><h1 id=title><a href=https://number317.github.io/blog/>cheon's blog</a></h1></section><ul id=nav><li>»
<a href=https://number317.github.io/blog/>cheon's blog</a></li><li>»
<a href=https://number317.github.io/blog/c/>c</a></li><li class=active>»
<a href=https://number317.github.io/blog/c/low_level_io/>Low Level I/O</a></li></ul><div id=content><main id=main><h1>Low Level I/O</h1><time>Last updated Tue Aug 27, 2019</time><div><aside><h2>Table of Content</h1><nav id=TableOfContents><ul><li><a href=#文件描述符>文件描述符</a></li><li><a href=#打开和创建文件>打开和创建文件</a></li><li><a href=#关闭文件>关闭文件</a></li><li><a href=#读写文件>读写文件</a></li><li><a href=#在文件中移动>在文件中移动</a></li><li><a href=#重复文件描述符>重复文件描述符</a></li><li><a href=#将文件描述符转化为文件指针>将文件描述符转化为文件指针</a></li></ul></nav></aside><article id=content><h1 id=底层-io>底层 I/O</h1><p>任务由标准 I/O 库函数执行，即缓冲和输入/输出转换，不总是可取的。例如，直接和诸如磁带驱动器之类的设备执行输入和输出时，程序员需要能够确定缓冲区要使用的大小，而不是让 stdio 的函数执行它。当然，系统提供这一层级的控制。标准 I/O 库是底层 I/O 库的一个用户友好的接口。</p><h2 id=文件描述符>文件描述符</h2><p>在标准 I/O 中，文件由文件指针引用。使用底层接口时，文件由文件描述符引用，由一个简单的整数来指代。在标准 I/O 中，有三个预先定义的文件描述符，0,1,2，分别指向标准输入，标准输出和标准错误输出。</p><p>不同于标准 I/O 库，为标准输入输出提供了速记函数，所有的底层 I/O 函数需要一个合适的文件描述符传递给它们。</p><h2 id=打开和创建文件>打开和创建文件</h2><p><code>open</code> 函数用于打开一个文件用于读写或创建。它接收三个参数：要打开文件名的字符串，一个整数指定文件的打开方式，一个整数 <code>mode</code> 当创建一个文件。成功时，它返回一个整数的文件描述符，失败时返回 -1。第二个参数在 <code>sys/file.h</code>(Berkeley) 或 <code>sys/fcntl.h</code>(System V)中定义如下：</p><ul><li><code>O_RDONLY</code> 只读模式</li><li><code>O_WRONLY</code> 只写模式</li><li><code>O_RDWR</code> 读写模式</li><li><code>O_APPEND</code> 追加模式</li><li><code>O_CREAT</code> 创建文件如果不存在，这个模式应该给出第三个参数</li><li><code>O_TRUNC</code> 截断文件长度为0用于写</li><li><code>O_EXCL</code> 返回错误如果创建文件时文件存在</li><li><code>O_NDELAY</code> 打开文件时不阻塞</li></ul><h2 id=关闭文件>关闭文件</h2><p><code>close</code> 函数用于关闭文件，只接收一个参数，引用于要关闭文件的文件描述符。成功时返回0；出错时返回-1。</p><h2 id=读写文件>读写文件</h2><p>在底层接口中读写文件只有一个办法，一次一个缓冲区。缓冲区大小留给程序员定义，需要确定一个合适的值。例如，如果一个程序一侧值读写一个字符而不是几千个字符，操作系统将为每个字符都访问一次硬盘（或其他设备），导致程序执行非常缓慢。</p><p><code>read</code> 系统调用接收三个参数：一个文件描述符用于读取，一个指针指向缓冲区等待填写数据，一个整数表示要读取的字节数。返回实际读取的字节数，或者出错时返回 -1，到达文件末尾时返回 0。</p><p><code>write</code> 系统调用接收三个参数：一个文件描述符用于写入，一个指针指向缓冲区存放要写的数据，一个整数表示要写入的字节数。返回实际写入的字节数，或者出错时返回 -1。</p><p>下面的代码实现了文件追加的功能：</p><details><summary>code</summary><div class="code-block code-block-container-indented"><pre><code id=code-892e1b0a4ef48ca953c13c60b22acbbd>#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(int argc, char *argv[]) {
    int n;
    int from, to;
    char buf[1024];
    if(argc!=3) {
        write(2, &#34;Usage: &#34;, 7);
        write(2, *argv, strlen(*argv));
        write(2, &#34;from-file to-file\n&#34;, 19);
        return 1;
    }

    if ((from=open(argv[1], O_RDONLY))&lt;0) {
        perror(argv[1]);
        return 1;
    }

    if((to=open(argv[2], O_WRONLY|O_CREAT|O_APPEND, 0644))&lt;0) {
        perror(argv[2]);
        return 1;
    }

    while (( n = read(from, buf, sizeof(buf)))&gt;0)
        write(to, buf, n);
    close(from);
    close(to);
    return 0;
}</code></pre><button class=copy-code-button onclick='copyCode("code-892e1b0a4ef48ca953c13c60b22acbbd",this)' title=copy>
<i class="fa fa-copy"></i></button></div></details><h2 id=在文件中移动>在文件中移动</h2><p>底层 I/O 库中在文件中移动调用 <code>lseek</code> 函数。就像 <code>fseek</code>，它接收三个参数：一个文件描述符指向一个打开的文件，一个长整型指定移动的字节数，称为偏移量，一个整型指定偏移量的起始位置。<code>L_SET</code>，即 0，设置为文件起始位置；<code>L_INCR</code>，即 1，设置为文件当前位置；<code>L_XTND</code>，即 2，设置为文件末尾位置。<code>lseek</code> 返回新的相对于文件起始的偏移量。要移动到文件末尾，调用 <code>lseek(fd, 0L, L_XTND)</code>。要移动到文件开头，调用 <code>lseek(fd, 0L, L_SET)</code>。</p><details><summary>code</summary><div class="code-block code-block-container-indented"><pre><code id=code-15f48c7e3727d534522970c12ac4aa5a>#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

typedef struct record {
    int uid;
    char login[8];
}record;

char *logins[]={&#34;user1&#34;, &#34;user2&#34;, &#34;user3&#34;, &#34;user4&#34;, &#34;user5&#34;};

void putrec(int, int, record *);

int main(int argc, char *argv[]) {
    int i, fd;
    record rec;
    if ((fd=open(&#34;datafile&#34;, O_WRONLY | O_CREAT, 0644)) &lt; 0) {
        perror(&#34;datafile&#34;);
        return 1;
    }

    for (i=4; i&gt;=0; i--) {
        rec.uid=i;
        strcpy(rec.login, logins[i]);
        putrec(fd, i, &amp;rec);
    }
    close(fd);
    return 0;
}

void putrec(int fd, int i, record *rec) {
    lseek(fd, (long)i*sizeof(record), L_SET);
    write(fd, rec, sizeof(record));
}</code></pre><button class=copy-code-button onclick='copyCode("code-15f48c7e3727d534522970c12ac4aa5a",this)' title=copy>
<i class="fa fa-copy"></i></button></div></details><p>下面的代码实现了以 3,0,2,1,4 的顺序读取刚刚创建的用户数据文件。</p><details><summary>code</summary><div class="code-block code-block-container-indented"><pre><code id=code-d4addc9945b196e2669b573f9e0aadfc>#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;

typedef struct record {
    int uid;
    char login[8];
}record;

int step[]={3, 0, 2, 1, 4};

void readrec(int, int, record *);

int main(int argc, char *argv[]) {
    int i, fd;
    record rec;
    if ((fd=open(&#34;datafile&#34;, O_RDONLY)) &lt; 0) {
        perror(&#34;datafile&#34;);
        return 1;
    }

    for (i=0; i&lt;5; i&#43;&#43;) {
        readrec(fd, step[i], &amp;rec);
        printf(&#34;%d\t%s\n&#34;, rec.uid, rec.login);
    }
    close(fd);
    return 0;
}

void readrec(int fd, int i, record *rec) {
    lseek(fd, (long)i*sizeof(record), L_SET);
    read(fd, rec, sizeof(record));
}</code></pre><button class=copy-code-button onclick='copyCode("code-d4addc9945b196e2669b573f9e0aadfc",this)' title=copy>
<i class="fa fa-copy"></i></button></div></details><h2 id=重复文件描述符>重复文件描述符</h2><p>我们偶尔需要超过一个文件描述符来指向同一个文件。这在另起新的进程时很常见。要生成一个和原来的 fd 指向同一个文件的新文件描述符，可以调用 <code>fd2=dup(fd)</code>。<code>fd2</code> 会和 <code>fd</code> 指向同一个文件并拥有相同的偏移量。如果调用失败，则返回 -1。</p><p>另一种调用方式允许程序员选择哪个文件描述符。例如，假设标准输入应该被连接到一个被<code>fd</code>引用的硬盘文件（这在 shell 中用 <code>&lt;</code> 来处理重定向），我们可以调用 <code>dup2(fd, 0)</code>。这将会使文件描述符 0 关闭如果它正在被使用，然后连接到 <code>fd</code> 指向的文件。</p><p>一个在 UNIX 源代码中很常见的代码块看起来像这样：</p><div class="code-block code-block-container-indented"><pre><code id=code-b9e654a994a449a3e1e2bc2f3324f0e3>close(0);
dup(fd);</code></pre><button class=copy-code-button onclick='copyCode("code-b9e654a994a449a3e1e2bc2f3324f0e3",this)' title=copy>
<i class="fa fa-copy"></i></button></div><p>这里 <code>dup</code> 的返回值被忽略了。实际上，这里依赖了 UNIX 系统的特性，最小的可用文件描述符总是最新被分配。</p><h2 id=将文件描述符转化为文件指针>将文件描述符转化为文件指针</h2><p><code>fdopen</code> 接收两个参数：一个文件描述符指向一个文件，一个字符串表明文件描述符被怎样使用。第二个参数和 <code>fopen</code> 一样。<code>fdopen</code> 返回一个文件指针，它的流和我文件描述符指向同一个文件，当失败时返回 <code>NULL</code>。</p></article></div></main><div><h4 id=signature>Tue Aug 27, 2019
cheon</h4><ul class=tags><li><a href=https://number317.github.io/blog/tags/library>library</a></li></ul><ul class=related><li><a class=previous href=https://number317.github.io/blog/c/standard_io/>Standard I/O</a></li><li><a class=next href=https://number317.github.io/blog/c/gnu_argp/>GNU Argp</a></li></ul></div></div><section id=footer><div id=author><h2>About Author</h2><hr><img src=https://number317.github.io/images/author.jpg></img><p>Life is dance we all have to do.</p></div><ul id=link><li><a href=https://github.com/number317/aloha.git target=_blank><i class="fa fa-github" alt=github></i></a></li><li><a href="mailto:cheon0112358d@gmail.com?subject=blog%27s%20feedback" target=_blank><i class="fa fa-envelope" alt=email></i></a></li><li id=wechat><i class="fa fa-wechat"></i></li><img class=qrcode src=https://number317.github.io/images/wechat.jpg></ul></section></body></html>